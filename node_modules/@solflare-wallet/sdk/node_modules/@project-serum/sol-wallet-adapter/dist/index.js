function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var EventEmitter = _interopDefault(require('eventemitter3'));
var web3_js = require('@solana/web3.js');
var bs58 = _interopDefault(require('bs58'));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Wallet = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(Wallet, _EventEmitter);

  function Wallet(provider, network) {
    var _this;

    _this = _EventEmitter.call(this) || this;

    _this._handleMessage = function (e) {
      if (_this._injectedProvider && e.source === window || e.origin === _this._providerUrl.origin && e.source === _this._popup) {
        if (e.data.method === 'connected') {
          var newPublicKey = new web3_js.PublicKey(e.data.params.publicKey);

          if (!_this._publicKey || !_this._publicKey.equals(newPublicKey)) {
            if (_this._publicKey && !_this._publicKey.equals(newPublicKey)) {
              _this._handleDisconnect();
            }

            _this._publicKey = newPublicKey;
            _this._autoApprove = !!e.data.params.autoApprove;

            _this.emit('connect', _this._publicKey);
          }
        } else if (e.data.method === 'disconnected') {
          _this._handleDisconnect();
        } else if (e.data.result || e.data.error) {
          if (_this._responsePromises.has(e.data.id)) {
            var _this$_responsePromis = _this._responsePromises.get(e.data.id),
                resolve = _this$_responsePromis[0],
                reject = _this$_responsePromis[1];

            if (e.data.result) {
              resolve(e.data.result);
            } else {
              reject(new Error(e.data.error));
            }
          }
        }
      }
    };

    _this._handleConnect = function () {
      if (!_this._handlerAdded) {
        _this._handlerAdded = true;
        window.addEventListener('message', _this._handleMessage);
        window.addEventListener('beforeunload', _this.disconnect);
      }

      if (_this._injectedProvider) {
        return new Promise(function (resolve) {
          _this._sendRequest('connect', {});

          resolve();
        });
      } else {
        window.name = 'parent';
        _this._popup = window.open(_this._providerUrl.toString(), '_blank', 'location,resizable,width=460,height=675');
        return new Promise(function (resolve) {
          _this.once('connect', resolve);
        });
      }
    };

    _this._handleDisconnect = function () {
      if (_this._handlerAdded) {
        _this._handlerAdded = false;
        window.removeEventListener('message', _this._handleMessage);
        window.removeEventListener('beforeunload', _this.disconnect);
      }

      if (_this._publicKey) {
        _this._publicKey = null;

        _this.emit('disconnect');
      }

      _this._responsePromises.forEach(function (_ref, id) {
        var reject = _ref[1];

        _this._responsePromises["delete"](id);

        reject('Wallet disconnected');
      });
    };

    _this._sendRequest = function (method, params) {
      try {
        if (method !== 'connect' && !_this.connected) {
          throw new Error('Wallet not connected');
        }

        var requestId = _this._nextRequestId;
        ++_this._nextRequestId;
        return Promise.resolve(new Promise(function (resolve, reject) {
          _this._responsePromises.set(requestId, [resolve, reject]);

          if (_this._injectedProvider) {
            _this._injectedProvider.postMessage({
              jsonrpc: '2.0',
              id: requestId,
              method: method,
              params: _extends({
                network: _this._network
              }, params)
            });
          } else {
            _this._popup.postMessage({
              jsonrpc: '2.0',
              id: requestId,
              method: method,
              params: params
            }, _this._providerUrl.origin);

            if (!_this.autoApprove) {
              _this._popup.focus();
            }
          }
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _this.connect = function () {
      if (_this._popup) {
        _this._popup.close();
      }

      return _this._handleConnect();
    };

    _this.disconnect = function () {
      try {
        var _temp3 = function _temp3() {
          if (_this._popup) {
            _this._popup.close();
          }

          _this._handleDisconnect();
        };

        var _temp4 = function () {
          if (_this._injectedProvider) {
            return Promise.resolve(_this._sendRequest('disconnect', {})).then(function () {});
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _this.sign = function (data, display) {
      try {
        if (!(data instanceof Uint8Array)) {
          throw new Error('Data must be an instance of Uint8Array');
        }

        return Promise.resolve(_this._sendRequest('sign', {
          data: data,
          display: display
        })).then(function (response) {
          var signature = bs58.decode(response.signature);
          var publicKey = new web3_js.PublicKey(response.publicKey);
          return {
            signature: signature,
            publicKey: publicKey
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _this.signTransaction = function (transaction) {
      try {
        return Promise.resolve(_this._sendRequest('signTransaction', {
          message: bs58.encode(transaction.serializeMessage())
        })).then(function (response) {
          var signature = bs58.decode(response.signature);
          var publicKey = new web3_js.PublicKey(response.publicKey);
          transaction.addSignature(publicKey, signature);
          return transaction;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _this.signAllTransactions = function (transactions) {
      try {
        return Promise.resolve(_this._sendRequest('signAllTransactions', {
          messages: transactions.map(function (tx) {
            return bs58.encode(tx.serializeMessage());
          })
        })).then(function (response) {
          var signatures = response.signatures.map(function (s) {
            return bs58.decode(s);
          });
          var publicKey = new web3_js.PublicKey(response.publicKey);
          transactions = transactions.map(function (tx, idx) {
            tx.addSignature(publicKey, signatures[idx]);
            return tx;
          });
          return transactions;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    if (isInjectedProvider(provider)) {
      _this._injectedProvider = provider;
    } else if (isString(provider)) {
      _this._providerUrl = new URL(provider);
      _this._providerUrl.hash = new URLSearchParams({
        origin: window.location.origin,
        network: network
      }).toString();
    } else {
      throw new Error('provider parameter must be an injected provider or a URL string.');
    }

    _this._network = network;
    _this._publicKey = null;
    _this._autoApprove = false;
    _this._popup = null;
    _this._handlerAdded = false;
    _this._nextRequestId = 1;
    _this._responsePromises = new Map();
    return _this;
  }

  _createClass(Wallet, [{
    key: "publicKey",
    get: function get() {
      return this._publicKey;
    }
  }, {
    key: "connected",
    get: function get() {
      return this._publicKey !== null;
    }
  }, {
    key: "autoApprove",
    get: function get() {
      return this._autoApprove;
    }
  }]);

  return Wallet;
}(EventEmitter);

function isString(a) {
  return typeof a === 'string';
}

function isInjectedProvider(a) {
  return isObject(a) && isFunction(a.postMessage);
}

function isObject(a) {
  return typeof a === 'object' && a !== null;
}

function isFunction(a) {
  return typeof a === 'function';
}

module.exports = Wallet;
//# sourceMappingURL=index.js.map
