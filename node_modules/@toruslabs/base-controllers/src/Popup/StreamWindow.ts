import { BroadcastChannel } from "@toruslabs/broadcast-channel";
import log from "loglevel";

import BaseController from "../BaseController";
import { COMMUNICATION_NOTIFICATIONS, POPUP_LOADED, SETUP_COMPLETE } from "../enums";
import { IWindow } from "../interfaces";
import { broadcastChannelOptions, randomId } from "../utils";
import { PopupData, StreamWindowConfig, StreamWindowState } from "./interfaces";

class StreamWindow extends BaseController<StreamWindowConfig, StreamWindowState> implements IWindow {
  // if window has been closed by users
  closed = false;

  constructor({
    config,
    state = {},
  }: {
    config: Partial<StreamWindowConfig> & Pick<StreamWindowConfig, "communicationEngine" | "communicationWindowManager">;
    state?: Partial<StreamWindowState>;
  }) {
    super({ config, state });
    this.initialize();
  }

  async open(): Promise<this> {
    return new Promise((resolve, reject) => {
      const { communicationEngine, communicationWindowManager } = this.config;

      communicationWindowManager.once(`${this.state.windowId}:closed`, () => {
        this.closed = true;
      });

      // Window is not open yet
      if (!this.state.windowId) {
        this.update({ windowId: randomId() });

        communicationWindowManager.once(`${this.state.windowId}:opened`, () => {
          resolve(this);
        });

        // Tell the other party to create a window by prompting the user to click on something
        communicationEngine.emit("notification", {
          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,
          params: {
            windowId: this.state.windowId,
            url: this.state.url.href,
          },
        });
      } else {
        // Send this window with `windowId` the url to open via bc
        const bc = new BroadcastChannel<PopupData<{ message: string }>>(this.state.windowId, broadcastChannelOptions);

        let writeInterval: number = null;
        bc.addEventListener("message", async (ev) => {
          try {
            log.info(ev, `receiving data on channel: ${bc.name}`);
            const { error } = ev;
            if (error) {
              // Popup says some error. so, we say it's not really opened
              reject(new Error(error));
              return;
            }
            const { message } = ev.data;
            if (message === POPUP_LOADED) {
              if (writeInterval) window.clearInterval(writeInterval);
              await bc.postMessage({
                data: {
                  url: this.state.url.href,
                  message: "", // No need of a msg
                },
              } as PopupData<{ message: string }>);
              resolve(this);
              bc.close();
            }
          } catch (error) {
            reject(error);
            bc.close();
            // Something went wrong. so, we close that window
            this.close();
          }
        });

        // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something
        writeInterval = window.setInterval(
          () => {
            bc.postMessage({
              data: {
                message: SETUP_COMPLETE,
              },
            } as PopupData<{ message: string }>);
          },
          bc.type === "server" ? 1000 : 200
        );
      }
    });
  }

  close(): void {
    const { communicationEngine } = this.config;
    communicationEngine.emit("notification", {
      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,
      params: {
        windowId: this.state.windowId,
      },
    });
  }
}

export default StreamWindow;
