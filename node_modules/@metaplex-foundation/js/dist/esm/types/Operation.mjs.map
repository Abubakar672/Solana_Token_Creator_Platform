{"version":3,"file":"Operation.mjs","sources":["../../../src/types/Operation.ts"],"sourcesContent":["import { Metaplex } from '@/Metaplex';\nimport { DisposableScope } from '@/utils';\n\nexport type KeyOfOperation<T> = T extends Operation<infer N, unknown, unknown>\n  ? N\n  : never;\nexport type InputOfOperation<T> = T extends Operation<string, infer I, unknown>\n  ? I\n  : never;\nexport type OutputOfOperation<T> = T extends Operation<string, unknown, infer O>\n  ? O\n  : never;\n\nexport type Operation<K extends string, I, O> = {\n  key: K;\n  input: I;\n\n  // This is necessary for type inference.\n  __output?: O;\n};\n\nexport type OperationConstructor<\n  T extends Operation<K, I, O>,\n  K extends string = KeyOfOperation<T>,\n  I = InputOfOperation<T>,\n  O = OutputOfOperation<T>\n> = {\n  key: string;\n  (input: I): T;\n};\n\nexport type OperationHandler<\n  T extends Operation<K, I, O>,\n  K extends string = KeyOfOperation<T>,\n  I = InputOfOperation<T>,\n  O = OutputOfOperation<T>\n> = {\n  handle: (\n    operation: T,\n    metaplex: Metaplex,\n    scope: DisposableScope\n  ) => O | Promise<O>;\n};\n\nexport const useOperation = <\n  T extends Operation<K, I, O>,\n  K extends string = KeyOfOperation<T>,\n  I = InputOfOperation<T>,\n  O = OutputOfOperation<T>\n>(\n  key: K\n): OperationConstructor<T, K, I, O> => {\n  const constructor = (input: I) => {\n    return {\n      key,\n      input,\n    } as T;\n  };\n  constructor.key = key;\n\n  return constructor;\n};\n"],"names":["useOperation","key","constructor","input"],"mappings":"AA4CaA,MAAAA,YAAY,GAMvBC,GAN0B,IAOW;EACrC,MAAMC,WAAW,GAAIC,KAAD,IAAc;IAChC,OAAO;MACLF,GADK;AAELE,MAAAA,KAAAA;KAFF,CAAA;GADF,CAAA;;EAMAD,WAAW,CAACD,GAAZ,GAAkBA,GAAlB,CAAA;AAEA,EAAA,OAAOC,WAAP,CAAA;AACD;;;;"}