{"version":3,"file":"OperationClient.mjs","sources":["../../../../src/plugins/operationModule/OperationClient.ts"],"sourcesContent":["import type { Metaplex } from '@/Metaplex';\nimport {\n  OperationConstructor,\n  Operation,\n  KeyOfOperation,\n  InputOfOperation,\n  OutputOfOperation,\n  OperationHandler,\n} from '@/types';\nimport { Task, TaskOptions } from '@/utils';\nimport { OperationHandlerMissingError } from '@/errors';\n\nexport class OperationClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /**\n   * Maps the name of an operation with its operation handler.\n   * Whilst the types on the Map are relatively loose, we ensure\n   * operations match with their handlers when registering them.\n   */\n  protected operationHandlers: Map<\n    string,\n    OperationHandler<any, any, any, any>\n  > = new Map();\n\n  register<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(\n    operationConstructor: OperationConstructor<T, K, I, O>,\n    operationHandler: OperationHandler<T, K, I, O>\n  ) {\n    this.operationHandlers.set(operationConstructor.key, operationHandler);\n\n    return this;\n  }\n\n  get<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(operation: T): OperationHandler<T, K, I, O> {\n    const operationHandler = this.operationHandlers.get(operation.key) as\n      | OperationHandler<T, K, I, O>\n      | undefined;\n\n    if (!operationHandler) {\n      throw new OperationHandlerMissingError(operation.key);\n    }\n\n    return operationHandler;\n  }\n\n  getTask<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(operation: T): Task<O> {\n    const operationHandler = this.get<T, K, I, O>(operation);\n\n    return new Task((scope) => {\n      return operationHandler.handle(operation, this.metaplex, scope);\n    });\n  }\n\n  execute<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(operation: T, options: TaskOptions = {}): Promise<O> {\n    return this.getTask<T, K, I, O>(operation).run(options);\n  }\n}\n"],"names":["OperationClient","constructor","metaplex","Map","register","operationConstructor","operationHandler","operationHandlers","set","key","get","operation","OperationHandlerMissingError","getTask","Task","scope","handle","execute","options","run"],"mappings":";;;;AAYO,MAAMA,eAAN,CAAsB;EAC3BC,WAAW,CAAoBC,QAApB,EAAwC;IAAA,eAU/C,CAAA,IAAA,EAAA,mBAAA,EAAA,IAAIC,GAAJ,EAV+C,CAAA,CAAA;;IAAA,IAApBD,CAAAA,QAAoB,GAApBA,QAAoB,CAAA;AAAE,GAAA;AAErD;AACF;AACA;AACA;AACA;;;AAMEE,EAAAA,QAAQ,CAMNC,oBANM,EAONC,gBAPM,EAQN;IACA,IAAKC,CAAAA,iBAAL,CAAuBC,GAAvB,CAA2BH,oBAAoB,CAACI,GAAhD,EAAqDH,gBAArD,CAAA,CAAA;AAEA,IAAA,OAAO,IAAP,CAAA;AACD,GAAA;;EAEDI,GAAG,CAKDC,SALC,EAK2C;IAC5C,MAAML,gBAAgB,GAAG,IAAA,CAAKC,iBAAL,CAAuBG,GAAvB,CAA2BC,SAAS,CAACF,GAArC,CAAzB,CAAA;;IAIA,IAAI,CAACH,gBAAL,EAAuB;AACrB,MAAA,MAAM,IAAIM,4BAAJ,CAAiCD,SAAS,CAACF,GAA3C,CAAN,CAAA;AACD,KAAA;;AAED,IAAA,OAAOH,gBAAP,CAAA;AACD,GAAA;;EAEDO,OAAO,CAKLF,SALK,EAKkB;AACvB,IAAA,MAAML,gBAAgB,GAAG,IAAA,CAAKI,GAAL,CAAqBC,SAArB,CAAzB,CAAA;AAEA,IAAA,OAAO,IAAIG,IAAJ,CAAUC,KAAD,IAAW;MACzB,OAAOT,gBAAgB,CAACU,MAAjB,CAAwBL,SAAxB,EAAmC,IAAKT,CAAAA,QAAxC,EAAkDa,KAAlD,CAAP,CAAA;AACD,KAFM,CAAP,CAAA;AAGD,GAAA;;AAEDE,EAAAA,OAAO,CAKLN,SALK,EAKSO,OAAoB,GAAG,EALhC,EAKgD;IACrD,OAAO,IAAA,CAAKL,OAAL,CAAyBF,SAAzB,EAAoCQ,GAApC,CAAwCD,OAAxC,CAAP,CAAA;AACD,GAAA;;AAhE0B;;;;"}