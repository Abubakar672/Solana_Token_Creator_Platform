'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.cjs');
var EventEmitterPackage = require('eventemitter3');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var EventEmitterPackage__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitterPackage);

class Disposable {
  constructor(signal) {
    _rollupPluginBabelHelpers.defineProperty(this, "cancelationError", null);

    this.signal = signal;
    this.eventEmitter = new EventEmitterPackage__default["default"].EventEmitter();

    this.abortListener = error => {
      this.cancelationError = error;
      this.eventEmitter.emit('cancel', error);
      this.close();
    };

    this.signal.addEventListener('abort', this.abortListener);
  }

  async run(callback, thenCloseDisposable = true) {
    try {
      return await Promise.resolve(callback(this.getScope()));
    } finally {
      if (thenCloseDisposable) {
        this.close();
      }
    }
  }

  getScope() {
    return {
      signal: this.signal,
      isCanceled: () => this.isCanceled(),
      getCancelationError: () => this.cancelationError,
      throwIfCanceled: () => {
        if (this.isCanceled()) {
          throw this.getCancelationError();
        }
      }
    };
  }

  isCanceled() {
    return this.signal.aborted;
  }

  getCancelationError() {
    return this.cancelationError;
  }

  onCancel(callback) {
    this.eventEmitter.on('cancel', callback);
    return this;
  }

  close() {
    this.signal.removeEventListener('abort', this.abortListener);
    this.eventEmitter.removeAllListeners();
  }

}

exports.Disposable = Disposable;
//# sourceMappingURL=Disposable.cjs.map
