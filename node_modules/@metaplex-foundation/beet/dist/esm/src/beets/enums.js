import { BEET_PACKAGE, BEET_TYPE_ARG_INNER, } from '../types';
import { u8 } from './numbers';
import { strict as assert } from 'assert';
function resolveEnumVariant(value, isNumVariant) {
    return (isNumVariant ? `${value}` : value);
}
/**
 * De/serializer for enums with up to 255 less variants which have no data.
 *
 * @param enumType type of enum to process, i.e. Color or Direction
 *
 * @category beet/enum
 */
export function fixedScalarEnum(enumType) {
    const keys = Object.keys(enumType);
    return {
        write(buf, offset, value) {
            const isNumVariant = typeof value === 'number';
            const variantKey = resolveEnumVariant(value, isNumVariant);
            if (!keys.includes(variantKey)) {
                assert.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);
            }
            if (isNumVariant) {
                u8.write(buf, offset, value);
            }
            else {
                const enumValue = enumType[variantKey];
                u8.write(buf, offset, enumValue);
            }
        },
        read(buf, offset) {
            const value = u8.read(buf, offset);
            const isNumVariant = typeof value === 'number';
            const variantKey = resolveEnumVariant(value, isNumVariant);
            if (!keys.includes(variantKey)) {
                assert.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);
            }
            return (isNumVariant ? value : enumType[variantKey]);
        },
        byteSize: u8.byteSize,
        description: 'Enum',
    };
}
/**
 * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.
 * The main difference to a Rust enum is that the type of data has to be the
 * same for all enum variants.
 *
 * @template T inner enum data type
 *
 * @param inner the De/Serializer for the data type
 *
 * @category beet/enum
 */
export function dataEnum(inner) {
    return {
        write: function (buf, offset, value) {
            u8.write(buf, offset, value.kind);
            inner.write(buf, offset + 1, value.data);
        },
        read: function (buf, offset) {
            const kind = u8.read(buf, offset);
            const data = inner.read(buf, offset + 1);
            return { kind, data };
        },
        byteSize: 1 + inner.byteSize,
        description: `DataEnum<${inner.description}>`,
    };
}
/**
 * Maps composite beet exports to metadata which describes in which package it
 * is defined as well as which TypeScript type is used to represent the
 * deserialized value in JavaScript.
 *
 * @category TypeDefinition
 */
export const enumsTypeMap = {
    fixedScalarEnum: {
        beet: 'fixedScalarEnum',
        isFixable: false,
        sourcePack: BEET_PACKAGE,
        ts: '<TypeName>',
        arg: BEET_TYPE_ARG_INNER,
        pack: BEET_PACKAGE,
    },
    dataEnum: {
        beet: 'dataEnum',
        isFixable: false,
        sourcePack: BEET_PACKAGE,
        ts: 'DataEnum<Kind, Inner>',
        arg: BEET_TYPE_ARG_INNER,
        pack: BEET_PACKAGE,
    },
};
//# sourceMappingURL=enums.js.map